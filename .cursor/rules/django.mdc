---
description: Django 框架规范，适用于后端 API 开发
globs: **/backend/**/*.py
alwaysApply: false
---

# Django 框架规范

## 项目结构
```
backend/
├── manage.py
├── config/              # 项目配置
│   ├── settings/
│   │   ├── base.py
│   │   ├── development.py
│   │   └── production.py
│   ├── urls.py
│   └── wsgi.py
├── apps/
│   ├── users/           # 用户模块
│   ├── recipes/         # 食谱模块
│   ├── ingredients/     # 食材模块
│   └── ai/              # AI 集成模块
├── common/              # 公共组件
│   ├── models.py        # 基础模型
│   ├── views.py         # 基础视图
│   └── utils.py
└── requirements/
    ├── base.txt
    ├── development.txt
    └── production.txt
```

## App 结构
```
apps/recipes/
├── __init__.py
├── admin.py             # Admin 配置
├── apps.py
├── models.py            # 数据模型
├── serializers.py       # DRF 序列化器
├── views.py             # 视图/ViewSet
├── urls.py              # 路由
├── services.py          # 业务逻辑
├── tests/
│   ├── test_models.py
│   └── test_views.py
└── migrations/
```

## Model 定义
```python
from django.db import models
from common.models import BaseModel

class Recipe(BaseModel):
    """食谱模型"""
    title = models.CharField("标题", max_length=100)
    difficulty = models.PositiveSmallIntegerField(
        "难度",
        choices=[(i, f"{i}星") for i in range(1, 6)]
    )
    duration = models.PositiveIntegerField("耗时(分钟)")
    ingredients = models.ManyToManyField(
        "ingredients.Ingredient",
        through="RecipeIngredient",
        verbose_name="食材"
    )

    class Meta:
        verbose_name = "食谱"
        verbose_name_plural = verbose_name
        ordering = ["-created_at"]
```

## Serializer 定义
```python
from rest_framework import serializers
from .models import Recipe

class RecipeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Recipe
        fields = ["id", "title", "difficulty", "duration", "created_at"]
        read_only_fields = ["id", "created_at"]

class RecipeDetailSerializer(RecipeSerializer):
    ingredients = IngredientSerializer(many=True, read_only=True)
    
    class Meta(RecipeSerializer.Meta):
        fields = RecipeSerializer.Meta.fields + ["ingredients"]
```

## ViewSet 定义
```python
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from .models import Recipe
from .serializers import RecipeSerializer, RecipeDetailSerializer
from .services import RecipeService

class RecipeViewSet(viewsets.ModelViewSet):
    queryset = Recipe.objects.all()
    serializer_class = RecipeSerializer
    
    def get_serializer_class(self):
        if self.action == "retrieve":
            return RecipeDetailSerializer
        return super().get_serializer_class()
    
    @action(detail=False, methods=["post"])
    def search_by_ingredients(self, request):
        """根据食材搜索食谱"""
        ingredient_ids = request.data.get("ingredients", [])
        recipes = RecipeService.search_by_ingredients(ingredient_ids)
        serializer = self.get_serializer(recipes, many=True)
        return Response(serializer.data)
```

## Service 层
- 复杂业务逻辑放在 Service 层
- View 层保持简洁，只处理请求/响应
- Service 方法使用 `@staticmethod` 或 `@classmethod`

## Admin 配置
```python
from django.contrib import admin
from .models import Recipe

@admin.register(Recipe)
class RecipeAdmin(admin.ModelAdmin):
    list_display = ["title", "difficulty", "duration", "created_at"]
    list_filter = ["difficulty", "created_at"]
    search_fields = ["title"]
```

## URL 配置
```python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import RecipeViewSet

router = DefaultRouter()
router.register("recipes", RecipeViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
```

## 配置管理
- 使用 django-environ 管理环境变量
- 敏感信息存储在 `.env` 文件
- 区分 development/production 配置

## API 规范
- 使用 Django REST Framework
- 遵循 RESTful 设计
- 统一响应格式
- 版本前缀：`/api/v1/`
